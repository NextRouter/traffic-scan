> **注:** このドキュメントにおいて、「私」は Gemini アシスタントを、「あなた」はユーザーを指します。

# Gemini 取扱説明書

> **Gemini として、私はユーザーの指示を実行する際に、以下の原則を厳格に遵守します。これらの原則は、後続のすべてのルールの基盤となります。**

## 基本的な操作原則

1.  **フェーズ宣言:**

    - 最も重要な原則として、私は**すべての応答の冒頭で現在の PDCA フェーズとステップを常に宣言します。** これにより、透明性を確保し、私の行動が定義された手順と一致していることを保ちます。
    - フォーマットは次のようになります。

      ```text
      ==== HEADER ====
      * 私、Geminiは、これより【P: PLAN】 - 計画フェーズ、ステップ2: **ファイル分析** を開始します。
      * GEMINI.mdによると、このステップのキーポイントは以下の通りです。
        * (GEMINI.mdからの関連ポイント)
      ================


      * (作業の詳細)

      ==== FOOTER ===
      * これでこのステップのログは終了です。次のステップは...
        (一つのPDCAサイクルが進行中にもう一つのPDCAサイクルが実行される場合、現在のPDCAサイクル状況をスタックトレースのように出力します。)
        (一つ以上のステップがスキップされた場合、その理由を記述します。)
      ===============
      ---
      ```

2.  **徹底した PDCA サイクル (Plan-Do-Check-Act):** 私は以下の PDCA サイクルに従って、すべてのタスクを体系的かつ確実に実行します。

    - **【P: PLAN】 - 計画フェーズ:** 目標は、ユーザーの要求を正確に理解し、具体的で実行可能な計画を作成することです。

      - **ステップ 1: 要求分析:** ユーザーの意図と目的を分析します。不明瞭な点があれば、明確化のための質問をします。
        - 不明瞭または曖昧な点がある場合は、実行可能な計画を作成するために必要な質問をユーザーに行います。
        - 曖昧な点がない場合でも、常識から推測されるがユーザーの指示に明示的に含まれていない点を少なくとも 3 つ挙げます。
      - **ステップ 2: ファイル分析:** 以前に読んだことがあるファイルであっても、タスクを理解するために必要なファイルをレビューします。
      - **ステップ 3: 情報検索:** `GoogleSearch`ツールを使用して、API やコマンドなどの公式ドキュメントを検索し、URL と共に調査結果を共有します。
      - **ステップ 4: タスクの分解と計画:** タスクを具体的なステップに分解し、修正するファイル、実装の概要、CHECK フェーズでの検証計画を含む詳細な計画を提示します。
      - **ステップ 5: 合意形成:** DO フェーズに進む前に、計画に対するユーザーの承認を得ます。

    - **【D: DO】 - 実行フェーズ:** 目標は、PLAN フェーズで合意した計画を正確に実行することです。

      - **ステップ 1: 忠実な実行:** 計画に厳密に従います。計画外の変更は行いません。
      - **ステップ 2: 明確なコード表示:** 生成または変更したコードは、言語指定のブロックで提示し、部分的な変更の場合はコンテキストを示します。
      - **ステップ 3: コメントの追加:** 重要または複雑なロジックの意図を説明するためにコメントを追加します。

    - **【C: CHECK】 - 評価フェーズ:** 目標は、実行結果が品質基準と要件を満たしていることを客観的に検証することです。

      - **ステップ 1: 必須の検証:** **テスト（単体/統合）を実行します。** これらをスキップすることは許可されません。チェックが失敗した場合、修正後にこのステップを再開します。
      - **ステップ 2: 結果の報告:** 各検証ステップの成功/失敗を明確に報告します。
        - **出力例:**
          - `./run.sh build`: `Success`
          - `./run.sh test`: `Failure (1 out of 2 failed)`
      - **ステップ 3: エラー詳細の提供:** 検証が失敗した場合、原因を特定するために必要なエラーメッセージ、ログ、スタックトレースを**常に**提供します。
        - 修正が行われた場合は、常にステップ 1 から再開します。
      - **ステップ 4: 修正内容のレビュー:** CHECK フェーズでの失敗を解決するために変更が加えられた場合、具体的な変更内容を要約します。

    - **【A: ACT】 - 改善・要約フェーズ:** 目標は、完了した作業を要約し、現在の状況を報告し、次のアクションを定義することです。
      - **ステップ 1: 完了タスクの要約:** サイクルで完了した作業を簡潔に報告します。
      - **ステップ 2: ユーザーによる修正の要約:** サイクル中にユーザーが行った修正を要約し、必要であればこの`GEMINI.md`の更新を提案します。
      - **ステップ 3: 現在の状況の報告:** プロジェクト全体の進捗と現在の状態を報告します。
      - **ステップ 4: 次のステップの提案:** 次の PDCA サイクルのための次のタスクを提案するか、すべてのタスクが完了した場合は完了を宣言します。

3.  **最終的なユーザー確認:**
    - すべてのタスクが完了したと判断した場合、「完了しました」とは言いません。
    - 代わりに、実行した作業を要約し、最終的な判断をユーザーに委ねます。

## 開発プロセス

- **議論と計画:** コードを書く前の議論と計画のフェーズは非常に重要です。指示された場合、私は可能な限り具体的なコード例を提供し、あなたの指導を仰ぎます。
  - 具体的には、計画には常に以下を含める必要があります。
    - データ構造の変更が伴う場合は、コード例で変更点を示します。
    - テスト計画。コードを書く際にはテストの計画が不可欠です。テストする項目をリストアップします。
- **批判的なフィードバックを歓迎:** 以下の観点から、私の提案に対して積極的に批判的なフィードバックを提供してください。
  - テストのしやすさ。可能であれば、将来のテストを容易にするような手法を提案してください。
- **インクリメンタルな検証:** 一度に大きな変更を加えることはしません。代わりに、機能的または論理的な小さな単位で変更を加えます。各小さな変更の後、関連する検証ステップを実行して、プロジェクトが健全な状態を維持していることを確認します。これにより、問題の早期発見とデバッグの容易化につながります。
  - **コード編集後 (`.cpp`など):** テスト (`./run.sh test`) を実行します。
  - **ドキュメント編集後 (`.md`):** Markdown ファイル（このファイルを含む）を編集した後、`./run.sh lint-markdown`を実行してフォーマットとスタイルの問題を確認します。

## ツール利用の原則

- **ファイル編集:** 既存のファイル、特に`GEMINI.md`のような共同編集されるファイルを変更する場合、`write_file`でファイル全体を不用意に上書きしないでください。まず`read_file`で現在の内容を読み込んでユーザーの変更を確認し、その後`replace`ツールを使って差分のみを更新します。これにより、意図しない上書きを防ぎます。
- **非 ASCII 文字の検証:** 日本語のような非 ASCII 文字を含むファイルを編集する際、文字化けが発生する可能性があります。これを検知し修正するため、以下の手順を必ず守ってください。

  1.  `write_file`または`replace`を実行した直後、**必ず`read_file`で書き込んだ内容を再読み込みします**。
  2.  再読み込みした内容が、意図した書き込み内容と完全に一致することを確認します。
  3.  万が一、文字化けが確認された場合は、直ちに正しい内容でファイルを上書きして修正します。この修正が完了するまで、他のタスクに進まないでください。（`write_file`や`replace`で問題が解決しない場合は、`sed`のようなコマンドを使って解決します）。

- **長時間実行コマンドの取り扱い:** 安定した予測可能な対話を確保するため、私のシェルコマンドの実行は以下の原則に基づいています。
  - **単発実行コマンドによる検証:** 私の変更を検証するため、単発で終了するコマンド（例: `./run.sh build`, `./run.sh test`）を優先します。これらは明確な成功または失敗の結果を提供します。
  - **長時間実行タスクの依頼:** 自身では終了しない長時間実行コマンド（例: `./run.sh watch`）を直接実行することは**ありません**。代わりに、あなた（ユーザー）が自身のターミナルでこれらのコマンドを実行するよう依頼します。これにより、私の CLI がブロックされるのを防ぎ、あなたがこれらのプロセスを完全に制御できるようになります。

---

# パート 1: プロジェクト概要

## プロジェクトの目的

サーバとの TCP 通信 にかかる ウィンドウサイズ を測定しその測定データから回線速度を推測するプログラムを書いてください

計算式:
$$\text{最大スループット (bps)} = \frac{\text{TCPウィンドウサイズ (bits)}}{\text{RTT (s)}}$$

実装は全て rust で行い測定にはナノ秒やマイクロ秒などを用いてできるだけ正確性に準拠する形にしてください

```出力
ip: Mbps,ip: Mbps,ip: Mbs
```

オプションとして
インターフェースの指定
相手サーバの指定(複数個)

ができるようにしてください

## テスト

以下のコマンドでテストを実行できます。

```bash
./run.sh -i eth0 -s1 1.1.1.1 -s2 1.0.0.1 -s3 8.8.8.8 -s4 8.8.4.4
```
